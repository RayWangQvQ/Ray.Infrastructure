name: PR Check & Preview Package

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review]

env:
  DOTNET_VERSION: '8.0.x'
  NUGET_SOURCE: 'https://api.nuget.org/v3/index.json'
  CSHARPIER_VERSION: '0.30.5'
  COVERAGE_THRESHOLD: '90'

jobs:
  pr-check:
    name: PR Quality Check
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-path: |
          ~/.nuget/packages

    - name: Restore dependencies
      run: dotnet restore

    - name: Check build
      run: |
        echo "üî® Building solution..."
        dotnet build --configuration Release --no-restore
        if [ $? -ne 0 ]; then
          echo "‚ùå Build failed!"
          exit 1
        fi
        echo "‚úÖ Build passed!"

    - name: Install CSharpier
      run: dotnet tool install -g csharpier --version ${{ env.CSHARPIER_VERSION }}

    - name: Check code formatting
      run: |
        echo "üé® Checking code formatting with CSharpier..."
        dotnet csharpier --check .
        if [ $? -ne 0 ]; then
          echo "‚ùå Code formatting check failed! Please run 'dotnet csharpier .' to fix formatting issues."
          exit 1
        fi
        echo "‚úÖ Code formatting check passed!"

    - name: Run unit tests
      run: |
        echo "üß™ Running unit tests..."
        # Remove any existing test results
        rm -rf ./TestResults
        
        # Run tests with coverage using cobertura format
        dotnet test \
          --configuration Release \
          --no-build \
          --verbosity normal \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults/ \
          --logger trx \
          --logger "console;verbosity=detailed" \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Include="[Ray.Infrastructure]*" \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Exclude="[Ray.Infrastructure.Tests]*"
        
        if [ $? -ne 0 ]; then
          echo "‚ùå Unit tests failed!"
          exit 1
        fi
        echo "‚úÖ Unit tests passed!"
        
        # List all coverage files for debugging
        echo "üìã Coverage files generated:"
        find ./TestResults -name "*.xml" -o -name "coverage.*" | head -10

    - name: Install ReportGenerator
      run: dotnet tool install -g dotnet-reportgenerator-globaltool

    - name: Generate coverage report
      run: |
        echo "üìä Generating coverage report..."
        
        # List all coverage files for debugging
        echo "üîç All coverage files found:"
        find ./TestResults -type f -name "*coverage*" -o -name "*.xml" | sort
        
        # Try to generate report with both opencover and cobertura formats
        COVERAGE_FILES=""
        
        # Look for cobertura files first
        if find ./TestResults -name "*.cobertura.xml" | grep -q .; then
          COVERAGE_FILES="TestResults/**/*.cobertura.xml"
          echo "üìã Found cobertura format files"
        # Fallback to opencover files
        elif find ./TestResults -name "*.opencover.xml" | grep -q .; then
          COVERAGE_FILES="TestResults/**/*.opencover.xml"
          echo "üìã Found opencover format files"
        # Look for any coverage.xml files
        elif find ./TestResults -name "coverage.xml" | grep -q .; then
          COVERAGE_FILES="TestResults/**/coverage.xml"
          echo "üìã Found generic coverage.xml files"
        else
          echo "‚ùå No coverage files found!"
          exit 1
        fi
        
        echo "üìÑ Using coverage files pattern: $COVERAGE_FILES"
        
        # Generate report with the found files
        reportgenerator \
          -reports:"$COVERAGE_FILES" \
          -targetdir:"CoverageReport" \
          -reporttypes:"Html;Cobertura;JsonSummary;TextSummary;Badges" \
          -verbosity:Info
        
        # Display detailed coverage information
        echo ""
        echo "üìà Detailed Coverage Analysis:"
        echo "=============================="
        
        # Show overall summary if available
        if [ -f "CoverageReport/Summary.txt" ]; then
          echo "üìä Overall Coverage Summary:"
          cat CoverageReport/Summary.txt
          echo ""
        fi
        
        # Parse and display class-level coverage from JSON
        if [ -f "CoverageReport/Summary.json" ]; then
          echo "üîç Class-level Coverage Details:"
          echo "--------------------------------"
          
          # Extract class coverage information using jq
          jq -r '
            .coverage.assemblies[] | 
            select(.name | contains("Ray.Infrastructure")) | 
            .classes[] | 
            select(.name != "") |
            "Class: \(.name)" + 
            " | Line Coverage: \(.lineCoverage)%" + 
            " | Branch Coverage: \(.branchCoverage)%" + 
            " | Lines: \(.coveredLines)/\(.coverableLines)"
          ' CoverageReport/Summary.json | sort -k3 -n
          
          echo ""
          echo "üìâ Classes with Low Coverage (< 50%):"
          echo "------------------------------------"
          
          jq -r '
            .coverage.assemblies[] | 
            select(.name | contains("Ray.Infrastructure")) | 
            .classes[] | 
            select(.name != "" and (.lineCoverage | tonumber) < 50) |
            "‚ùå \(.name): \(.lineCoverage)% (\(.coveredLines)/\(.coverableLines) lines)"
          ' CoverageReport/Summary.json | sort -k2 -n
          
          echo ""
          echo "‚úÖ Classes with Good Coverage (>= 80%):"
          echo "--------------------------------------"
          
          jq -r '
            .coverage.assemblies[] | 
            select(.name | contains("Ray.Infrastructure")) | 
            .classes[] | 
            select(.name != "" and (.lineCoverage | tonumber) >= 80) |
            "‚úÖ \(.name): \(.lineCoverage)% (\(.coveredLines)/\(.coverableLines) lines)"
          ' CoverageReport/Summary.json | sort -k2 -nr
          
          echo ""
          echo "üìã Namespace Coverage Summary:"
          echo "-----------------------------"
          
          jq -r '
            .coverage.assemblies[] | 
            select(.name | contains("Ray.Infrastructure")) | 
            "Assembly: \(.name)" +
            " | Line Coverage: \(.lineCoverage)%" +
            " | Branch Coverage: \(.branchCoverage)%" +
            " | Total Lines: \(.coveredLines)/\(.coverableLines)"
          ' CoverageReport/Summary.json
          
        else
          echo "‚ö†Ô∏è Summary.json not found, cannot display detailed class coverage"
        fi

    - name: Check coverage threshold
      run: |
        echo "üìà Checking test coverage..."
        
        # Extract coverage percentage from the JSON summary
        if [ -f "CoverageReport/Summary.json" ]; then
          coverage=$(cat CoverageReport/Summary.json | jq -r '.summary.linecoverage')
          echo "Current coverage: ${coverage}%"
          
          # Remove % sign and convert to number for comparison
          coverage_num=$(echo $coverage | sed 's/%//')
          
          if (( $(echo "$coverage_num >= ${{ env.COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "‚úÖ Coverage check passed! (${coverage}% >= ${{ env.COVERAGE_THRESHOLD }}%)"
          else
            echo "‚ùå Coverage check failed! Current: ${coverage}%, Required: ${{ env.COVERAGE_THRESHOLD }}%"
            exit 1
          fi
        else
          echo "‚ùå Coverage report not found!"
          exit 1
        fi

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: CoverageReport/

    - name: Read version from common.props
      id: read-version
      run: |
        echo "üìã Reading version from common.props..."
        version=$(grep -oP '(?<=<Version>)[^<]+' common.props)
        preview_version="${version}-preview.$(date +%Y%m%d%H%M%S)"
        echo "Base version: $version"
        echo "Preview version: $preview_version"
        echo "version=$version" >> $GITHUB_OUTPUT
        echo "preview_version=$preview_version" >> $GITHUB_OUTPUT

    - name: Pack NuGet package
      run: |
        echo "üì¶ Creating preview NuGet package..."
        mkdir -p ./bin/nupkgs
        rm -rf ./bin/nupkgs/*
        
        dotnet pack src/Ray.Infrastructure/Ray.Infrastructure.csproj \
          --configuration Release \
          --no-build \
          --output ./bin/nupkgs \
          -p:PackageVersion=${{ steps.read-version.outputs.preview_version }} \
          -p:VersionSuffix=preview.$(date +%Y%m%d%H%M%S)
        
        echo "‚úÖ Package created successfully!"
        ls -la ./bin/nupkgs/

    - name: Upload NuGet package artifact
      uses: actions/upload-artifact@v4
      with:
        name: nuget-package
        path: ./bin/nupkgs/*.nupkg

    - name: Push to NuGet (Preview)
      if: success()
      run: |
        echo "üöÄ Pushing preview package to NuGet..."
        
        if [ -z "${{ secrets.NUGET_API_KEY }}" ]; then
          echo "‚ö†Ô∏è NUGET_API_KEY secret not found. Skipping package push."
          echo "Please add your NuGet API key as a repository secret named 'NUGET_API_KEY'"
        else
          for package in ./bin/nupkgs/*.nupkg; do
            echo "Pushing $package..."
            dotnet nuget push "$package" \
              --api-key ${{ secrets.NUGET_API_KEY }} \
              --source ${{ env.NUGET_SOURCE }} \
              --skip-duplicate
          done
          echo "‚úÖ Preview package pushed to NuGet successfully!"
        fi

    - name: Comment PR with results
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          
          let coverageInfo = '';
          try {
            const summaryPath = 'CoverageReport/Summary.json';
            if (fs.existsSync(summaryPath)) {
              const summary = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
              coverageInfo = `üìä **Test Coverage**: ${summary.summary.linecoverage}%`;
            }
          } catch (error) {
            coverageInfo = 'üìä **Test Coverage**: Unable to read coverage data';
          }
          
          const packageVersion = '${{ steps.read-version.outputs.preview_version }}';
          const jobStatus = '${{ job.status }}';
          const statusEmoji = jobStatus === 'success' ? '‚úÖ' : '‚ùå';
          
          const comment = `## ${statusEmoji} PR Check Results
          
          **Status**: ${jobStatus.toUpperCase()}
          **Preview Version**: \`${packageVersion}\`
          ${coverageInfo}
          
          ### Checks Performed:
          - üî® **Build**: ${jobStatus === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}
          - üé® **Code Formatting**: ${jobStatus === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}  
          - üß™ **Unit Tests**: ${jobStatus === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}
          - üìà **Coverage (‚â•${{ env.COVERAGE_THRESHOLD }}%)**: ${jobStatus === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}
          - üì¶ **Package Creation**: ${jobStatus === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}
          - üöÄ **Preview Publish**: ${jobStatus === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}
          
          ${jobStatus === 'success' ? 
            'üéâ All checks passed! This PR is ready for review.' : 
            'üö® Some checks failed. Please fix the issues before merging.'}
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
